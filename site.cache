[{'category': '', 'index': False, 'subpages': [], 'target': u'week-4.html', 'title': '', 'url': u'week-4.html', 'checksum': "/]J\xf3\x18M\r\x1e\xf2\xf9\x90\x18'I\xe1\xc7", 'rel_site_url': '.', 'excerpt': u'Intersections of Infinitely indexed sets This week I implemented a method to do intersection of imagesets using the solutions of Diophantine equations at PR. Say you have to find the intersection of sets 2*n| n in Integers and 3*m| m in Integers. The intersection of these sets is the set ...', 'modified': 1429646554.4803371, 'filename': '/home/hargup/210fs/posts/week-4.md', 'content': u'<!--\n.. title: week 4\n.. slug: week-4\n.. date: 2014/06/18 11:29:01\n.. tags: sympy, GSoC\n.. link:\n.. description:\n.. type: text\n-->\n\n<h2>Intersections of Infinitely indexed sets</h2>\n<p>This week I implemented a method to do intersection of imagesets using the\nsolutions of Diophantine equations at <a href="https://github.com/sympy/sympy/pull/7587">PR</a>.</p>\n<p>Say you have\nto find the intersection of sets <code>2*n| n in Integers</code> and <code>3*m| m in Integers</code>.\nThe intersection of these sets is the set of the common values in the two sets,\nwhich in this case is equivalent to the values of <code>n</code> for which the equation <code>2*n - 3*m</code> has\nsome integral solution in <code>m</code>. Or the values of <code>m</code> for which the <code>2*n - 3*m</code>\nhas some integral solution in <code>n</code>. Diophantine equations are equations for\nwhich only integral solutions are searched for.\nThe Diophantine module was written by\n<a href="https://github.com/thilinarmtb">Thilina</a> as his GSoC project last year.\nIt gives the parametric solution for such equation.</p>\n<div class="codehilite"><pre>In [17]: diophantine(2*n - 3*m)\nOut[17]: {(-2*t, -3*t)}\n</pre></div>\n\n\n<p>The Solution is sorted according to alphabetic order of the variables involved.\nSo the value of LHS (<code>2*n</code>) for which the equation is <code>2*(-3*t)</code> that is <code>-6*t</code>\nand it is the intersection of the sets described above <code>-6*t| t in Integers</code>.\nSince <code>-6*t| t in Integers</code> is same as <code>6*t| t in Integers</code> I also wrote some\nsimplification rules for the imagesets with Integers as baseset.</p>\n<h2>Sets for Invert Function</h2>\n<p>The sets module turned out to be better than I expected. I had a perception\nthat substitutions doesn\'t work properly with sets and I have even opened an\n<a href="https://github.com/sympy/sympy/issues/7483">issue</a> for that but it turned out\nI hadn\'t looked closely enough. It worked well for the free variables and it\ndidn\'t worked for the things it shouldn\'t work i.e., the bound variables in the\nimagesets.</p>\n<p>Using sets simplified the code. All the list comprehensions like this\n<code>[i.subs(symbol, symbol/g) for i in _invert(h, symbol)]</code> were converted to\nsimple substitutions for sets and other sets operations.  <code>_invert(h,\nsymbol).subs(symbol, symbol/g)</code></p>\n<p>Just by changing the output of invert to sets, then by adding the inverse of\ntrigonometric function and writing the code to rewrite then as tan I was able\nto return all the solutions of the equations like <code>cos(x) + sin(x) == 0</code> it\nturned to out to easier than I thought. Using sets as output makes thinking\nabout the mathematics of the solvers much more easier and the code comes\nout to be pretty natural. Now when we can see the results I can surely say\nthere can be no better output for solvers than sets.</p>\n<p>This week I\'ll study LambertW function and then code additional techniques to\nsolve real equations. I\'ll also try to figure out techniques to perform Union\non infinitely indexed sets.</p>', 'sort_key': None, 'max_subpages': None, 'template': 'default.haml', 'sort_reverse': True, 'date': datetime.datetime(2015, 4, 22, 0, 0), 'slug': u'week-4'}, {'category': '', 'index': False, 'subpages': [], 'target': u'week-11.html', 'title': '', 'url': u'week-11.html', 'checksum': '\xed\xf0W\xf4^\xc5\xf5q\xb1Z\r\xb8L\xb7\x17O', 'rel_site_url': '.', 'excerpt': u'The GSoC is about to end. We have the suggested deadline tomorrow and the firm deadline next week. We are wrapping up the project now, cleaning up the code, writing the documentation and turning the project into a usable state. Since the new solvers cannot be called compelete I have ...', 'modified': 1429646554.4803371, 'filename': '/home/hargup/210fs/posts/week-11.md', 'content': u'<p>The GSoC is about to end. We have the suggested deadline tomorrow and the firm\ndeadline next week. We are wrapping up the project now, cleaning up the code,\nwriting the documentation and turning the project into a usable state.\nSince the new solvers cannot be called compelete I have to make sure that the\nnext person working on it can pick it up easily. I plan come up with a post with\nthe summary of the work that was done, that challenges we faced and thing that\nneeds to done and how can they be tackled.</p>', 'sort_key': None, 'max_subpages': None, 'template': 'default.haml', 'sort_reverse': True, 'date': datetime.datetime(2015, 4, 22, 0, 0), 'slug': u'week-11'}, {'category': '', 'index': False, 'subpages': [], 'target': u'week-5.html', 'title': '', 'url': u'week-5.html', 'checksum': 'P\xa4j\xd0M\xb5S9\xcc%m\x00\x9e\xdc\x02\xa7', 'rel_site_url': '.', 'excerpt': u'Solving Trigonometric Function (part I) This week I spend time on making trigonometric solvers work. Every trigonometric function can be written in terms of tan. $$ sin(x) = \\frac{2*tan(x/2)}{tan^{2}(x/2)} $$ $$ cos(x) = \\frac{-tan^{2}(x/2) + 1}{tan^{2}(x/2) + 1} $$ $$ cot(x) = \\frac{1}{tan(x)} $$ A basic technique to solve trigonometric ...', 'modified': 1429646554.4803371, 'filename': '/home/hargup/210fs/posts/week-5.md', 'content': u'<h2>Solving Trigonometric Function (part I)</h2>\n<p>This week I spend time on making trigonometric solvers work.\nEvery trigonometric function can be written in terms of tan.</p>\n<p>$$ sin(x) = \\frac{2*tan(x/2)}{tan^{2}(x/2)} $$</p>\n<p>$$ cos(x) = \\frac{-tan^{2}(x/2) + 1}{tan^{2}(x/2) + 1} $$</p>\n<p>$$ cot(x) = \\frac{1}{tan(x)} $$</p>\n<p>A basic technique to solve trigonometric equations can be rewriting the equation in terms of tan.\nAnd if the equation is made by addition, multiplication or quotient of\ntrigonometric functions then the transformed equation is a equivalent to a rational\nfunction in tan. That equation can be solved by the usual polynomial\nsolving techniques.</p>\n<p>Taking the example from the <a href="https://github.com/sympy/sympy/wiki/solvers">doc</a>\n\\( cos(x) + sin(x) \\) gets converted to\n\\( \\frac{-tan^{2}(x/2) + 2*tan(x/2) + 1}{tan^{2}(x/2) + 1} \\)</p>\n<p>The solution of this equations is \\( tan(x/2) = 1 +- sqrt(2) \\).\nSince the inverse of tan is\n\\( \\left\\{2 \\pi n + \\operatorname{atan}{\\left (y \\right )}\\; |\\; n \\in \\mathbb{Z}\\right\\} \\)\nthe solution of the given equation is\n$$ \\left\\{2 \\pi n - \\frac{\\pi}{8}\\; |\\; n \\in \\mathbb{Z}\\right\\} \\cup \\left\\{2 \\pi n + \\frac{3 \\pi}{8}\\; |\\; n \\in \\mathbb{Z}\\right\\} $$</p>\n<p>Though it appears this technique should work universally for trigonometric\nequation it fails for even \\( sin(x) = 0 \\). From the table above\n\\( sin(x) = \\frac{2*tan(x/2)}{tan^{2}(x/2)} \\)\nSo, the \\( sin(x) = 0 \\) occurs at \\( tan(x/2) = 0 \\) which has solution\n\\( \\left\\{2 \\pi n\\; |\\; n \\in \\mathbb{Z}\\right\\} \\)\nBut the solution is \\( \\left\\{ \\pi n\\; |\\; n \\in \\mathbb{Z}\\right\\} \\)\n. Why are we missing some solutions? The\nreason is \\( sin(x) = 0 \\) also occurs when denominator tends to \\( \\infty \\),\ni.e.,\nthe values where \\( tan^{2}(x/2) + 1 \\) tends to \\( \\infty \\).\nWe had encountered a similar problem for the solution of\n$$ \\frac{1}{\\left(\\frac{x}{x + 1} + 3\\right)^{2}} $$</p>\n<p>here \\( x = -1 \\) is not a point in the domain of the of the equation. The solver\nsimplifies the equation to</p>\n<p>$$ \\frac{\\left(x + 1\\right)^{2}}{\\left(4 x + 3\\right)^{2}} $$</p>\n<p>which extends the domain to include the point \\( x = -1 \\) which is also the\nsolution to the transformed equation. There we wrote a sub procedure\n<code>domain_check</code> to verify if the returned solution is part of the domain of the\noriginal equation. The problem here is slightly different in the sense that\ntransforming the equation decreases the domain of the solutions and not increase\nit.</p>\n<p>To find such solution we have allow \\( \\infty \\) to be solution to equations, we\nwill be working on extended reals instead of just reals.  I think this change\nwill simplify a lot of things.</p>\n<p>Another thing which should be taken care off is that we cannot naively search\nfor the values for which the denominator tends to infinity as for the same\nvalue numerator might also attain infinitely large value, we will have to\nconceder the limiting value of the equation.</p>\n<!--\nA technique followed by current solvers is.\n- Git Rebase\n- The tan technique\n- The problems with tan technique\n- the Exp technique\n- The problem with exp technique\n- Complex logarithms and multivalued(set valued) functions\n-->', 'sort_key': None, 'max_subpages': None, 'template': 'default.haml', 'sort_reverse': True, 'date': datetime.datetime(2015, 4, 22, 0, 0), 'slug': u'week-5'}, {'category': '', 'index': False, 'subpages': [], 'target': u'week-3.html', 'title': '', 'url': u'week-3.html', 'checksum': 'e\x16t\xc2>"\x87\xc2\xab&\x7f\xc3\x81\xa1\xe7\x0b', 'rel_site_url': '.', 'excerpt': u'Hi, At the start of this week I wrote a method to check if a given solution lies in the domain of the equation or not. The problem it targeted was equations like (x - 1)/(1 + 1/(x - 1)) though at x = 1 the eqution has value zero ...', 'modified': 1429646554.4803371, 'filename': '/home/hargup/210fs/posts/week-3.md', 'content': u"<!--\n.. title: week 3\n.. slug: week-3\n.. date: 2014/06/09 20:20:06\n.. tags: sympy, GSoC\n.. link:\n.. description:\n.. type: text\n.. author: Harsh Gupta\n-->\n\n<p>Hi,\nAt the start of this week I wrote a method to check if a given solution\nlies in the domain of the equation or not. The problem it targeted was equations like <code>(x\n- 1)/(1 + 1/(x - 1))</code> though at <code>x = 1</code> the eqution has value zero the point is\nnot present in the domain of the given equation. Though there is some\ndisagreement on the implementation, the idea was to traverse the expression\ntree and check if any of the subexpression goes unbounded for the given\nvalue.  Later I observed that caching was messing with the tests. Sometimes\nthe tests passed and sometimes the same test suit run without any\nmodification in the code failed. To do the check on the subexpressions I need\nto have a copy of the original equation before the solver performs any\nsimplification on it. Being not sure of the mutability of the equations\nI used deepcopy to copy the original equation to a variable. Later in a\nmeeting we figured out that deepcopy was messing with caching. Aaron told me\nthat every expression in sympy is immutable so don't need to perform deepcopy\non anything.</p>\n<p>This week we will restart working on the sets to represent infinite solutions,\nAlmost every equation in complex domain other than polynomials and rationals\nhas infinitly many solutions. For example even the simple equation <code>exp(x) ==\n1</code> has infinitely many solutions that is <code>i*2*n*pi</code> where <code>n</code> is an integer.\nTo return these solutions we first need to have infrastructure to handle them.\nThe old(current) solvers does it wrong, it implicity mixes up the complex and real\ndomains, the answer it returns to <code>exp(x) == 1</code> is only <code>[0]</code>. Earlier I was also doing it wrong\nso I decided that I should have two seperate solvers for reals and complex\ninstead of one. This also simplifed the code for the reals solvers to a large\nextent.</p>", 'sort_key': None, 'max_subpages': None, 'template': 'default.haml', 'sort_reverse': True, 'date': datetime.datetime(2015, 4, 22, 0, 0), 'slug': u'week-3'}, {'category': '', 'index': False, 'subpages': [], 'target': u'week-1-and-week-2.html', 'title': '', 'url': u'week-1-and-week-2.html', 'checksum': '\x93l\xf5\xf4\x13\x14\x99\xab\x95W1\xdc~\xa6\x01\x89', 'rel_site_url': '.', 'excerpt': u"Hi, As I told you about in the previous post, My work for this summer will be improving the current equation solvers of sympy. There are basically three thing I'll have to do. Create a basic set infrastructure for solvers to return sets. Rewrite the current solvers to be clean ...", 'modified': 1429646554.4803371, 'filename': '/home/hargup/210fs/posts/week-1-and-week-2.md', 'content': u'<!--\n.. title: Week 1 and Week 2\n.. slug: week-1-and-week-2\n.. date: 2014/06/02 17:15:54\n.. tags: sympy, GSoC\n.. link:\n.. description:\n.. type: text\n-->\n\n<p>Hi, As I told you about in the previous post, My work for this summer will be\nimproving the current equation solvers of sympy. There are basically three\nthing I\'ll have to do.</p>\n<ol>\n<li>Create a basic set infrastructure for solvers to return sets.</li>\n<li>Rewrite the current solvers to be clean and robust.</li>\n<li>On the top of 1 and 2 write new solvers and function, they will returning\n   and handling all the solutions of equations like <code>sin(x) == 0</code> and a general\n   singularity finder.</li>\n</ol>\n<p>You can look at the details in my\n<a href="https://github.com/sympy/sympy/wiki/GSoC-2014-Application-Harsh-Gupta:-Solvers">proposal</a></p>\n<p>A started working on the sets module in the community bonding period, basically\nwriting a set difference class at <a href="https://github.com/sympy/sympy/pull/7462">this\nPR</a> , I try to get it merged by the\nend of this week.</p>\n<p>Set are a pretty general mathematical constructs, and you can solve a lot of\nhard problems if you could compute general set operations. The whole number\ntheory can be defined in terms of sets. So, computing general set operations,\ne.g, intersection, unions is pretty hard problem too and we should not aim to\ndo all them.  In a meeting with Matthew and Sergey we discussed that it would\n    be better if complete the part 2 first. It will give a general idea about\n    what capabilities of sets we need.  Also some sets problems can be reduced\n    to equations and vice versa.  <!-- Explain --></p>\n<p>I\'ve started working on the univariate solvers <a href="https://github.com/sympy/sympy/pull/7523">at\nPR</a>.  My aim for this\nweek will be.</p>\n<ol>\n<li>Completing the rational solvers</li>\n<li>Getting the open PR for the sets merged.</li>\n</ol>', 'sort_key': None, 'max_subpages': None, 'template': 'default.haml', 'sort_reverse': True, 'date': datetime.datetime(2015, 4, 22, 0, 0), 'slug': u'week-1-and-week-2'}, {'category': '', 'index': False, 'subpages': [], 'target': u'week-9.html', 'title': '', 'url': u'week-9.html', 'checksum': '\xd6\xb76\x9d\x90\x1b0/\xe9R\xda\xa4\x95\x82\x0ft', 'rel_site_url': '.', 'excerpt': u'This week I moved back to college and my classes have restarted. This week I worked on a PR to allow infinitely indexed Range. See https://github.com/sympy/sympy/pull/7741. While doing this PR I discovered that you cannot monkey patch object to assign some attribute. And I want to mention that Sergey(one of ...', 'modified': 1429646554.4803371, 'filename': '/home/hargup/210fs/posts/week-9.md', 'content': u'<p>This week I moved back to college and my classes have restarted. This week\nI worked on a PR to allow infinitely indexed <code>Range</code>. See\nhttps://github.com/sympy/sympy/pull/7741. While doing this PR I discovered\nthat you cannot monkey patch <code>object</code> to assign some attribute. And I want to\nmention that Sergey(one of my mentors) is damn good reviewer.</p>', 'sort_key': None, 'max_subpages': None, 'template': 'default.haml', 'sort_reverse': True, 'date': datetime.datetime(2015, 4, 22, 0, 0), 'slug': u'week-9'}, {'category': '', 'index': False, 'subpages': [], 'target': u'week-6.html', 'title': '', 'url': u'week-6.html', 'checksum': '\x9b+F\\*\xd1O\x11\xc0z\x03:\xcd4\x90\xa3', 'rel_site_url': '.', 'excerpt': u'Solving Trigonometric Function (part II) There is another technique to solve trigonometric function. Just as every trigonometric function can be written in term of \\( \\tan \\) it can also be written in terms of \\( \\exp \\). $$ sin(x) = - \\frac{i}{2} \\left(e^{i x} - e^{- i x}\\right) $$ ...', 'modified': 1429646554.4803371, 'filename': '/home/hargup/210fs/posts/week-6.md', 'content': u'<h2>Solving Trigonometric Function (part II)</h2>\n<p>There is another technique to solve trigonometric function. Just as every\ntrigonometric function can be written in term of \\( \\tan \\) it can also be written\nin terms of \\( \\exp \\).</p>\n<p>$$ sin(x) = - \\frac{i}{2} \\left(e^{i x} - e^{- i x}\\right) $$\n$$ cos(x) = \\frac{e^{i x}}{2} + \\frac{1}{2} e^{- i x} $$\n$$ tan(x) = \\frac{i \\left(- e^{i x} + e^{- i x}\\right)}{e^{i x} + e^{- i x}} $$\n$$ cot(x) = \\frac{i \\left(e^{i x} + e^{- i x}\\right)}{e^{i x} - e^{- i x}} $$</p>\n<p>So, solving a trigonometric equation is equivalent to solving a rational\nfunction in \\( \\exp \\). Note: here the \\( \\exp \\) is in complex domain and\nequation \\( exp(x) = y \\) has solution\n\\( \\left\\{i \\left(2 \\pi n + \\arg{\\left (y \\right )}\\right) + \\log{\\left (\\left\\lvert{y}\\right\\rvert \\right )}\\; |\\; n \\in \\mathbb{Z}\\right\\} \\)\nwhen solved for \\( x \\).</p>', 'sort_key': None, 'max_subpages': None, 'template': 'default.haml', 'sort_reverse': True, 'date': datetime.datetime(2015, 4, 22, 0, 0), 'slug': u'week-6'}, {'category': '', 'index': False, 'subpages': [], 'target': u'week-10.html', 'title': '', 'url': u'week-10.html', 'checksum': 'N=Ke\xf9\xef9\xca\xe1\xd6\x1d\xb5J-d;', 'rel_site_url': '.', 'excerpt': u'This week I worked on the solvers for the equations with radicals. Suppose you have to solve $$ \\sqrt{x} + x - 2 = 0 $$. then you have to move the radical to the right hand side of the equation. $$ x - 2 = - \\sqrt{x} $$ and ...', 'modified': 1429646554.476337, 'filename': '/home/hargup/210fs/posts/week-10.md', 'content': u'<p>This week I worked on the solvers for the equations with radicals.\nSuppose you have to solve</p>\n<p>$$ \\sqrt{x} + x - 2 = 0 $$.</p>\n<p>then you have to move the radical to the right hand side of the equation.</p>\n<p>$$ x - 2 = - \\sqrt{x} $$</p>\n<p>and then square at both sides</p>\n<p>$$ x^2 - 4x + 4 = x $$</p>\n<p>Now the equation is a polynomial in \\( x \\) can be solved with usual\npolynomial solving methods. Note that squaring both sides produce some extra\nsolutions and we will have to check all the solutions obtained against the\noriginal equation.  If there are more than one radicals involved we may\nhave to apply the method recursively. For example in solving\n\\( \\sqrt{2x + 9} - \\sqrt{x + 1} - \\sqrt{x + 4} = 0 \\)\nthe method will recurse twice.</p>\n<p>To implement the method I tried a pattern matching approach.\nThe\nsquaring part is easy the tricky part is identifying which part to move to\nthe right hand side. First I tried to match the expression with the form\n<code>sqrt(p) + q</code> but it failed even for case like <code>4*sqrt(x) + x - 2</code> because no\npattern matched to it. I had to use <code>a*sqrt(p) + q</code> with the condition that the\nexpression matched to a shouldn\'t be zero. Now I can simply move the expression\nmatched with <code>p</code> and terms multiplicated with it to the RHS and square both\nthe sides.</p>\n<p>Notice that this method for solving sqrt equation can work with any radical\nequation, if it were cube root instead of sqrt I just had to cube both the\nsides. OK so how do I mathch that expression? I tried to pattern matching with\nassumptions on the wild symbols but it doesn\'t work.  I tried to match with\nsomthing like <code>a*p**Rational(1, m) + q</code> but this also didn\'t work out because\nRational(1, m) raises TypeError no matter what the assumption on the variable\nare.  There is a proposal for a new pattern matcher, I have not closely checked\nthe details but it will be able to work with assumption. You can see the\nproposal on the wiki\n<a href="https://github.com/sympy/sympy/wiki/Proposal-for-a-new-pattern-matching">here</a>\nand if it is implemented then things will be good but I can\'t wait for it.\nI had no other option to check term by term for rational power. Here\'s the\nimplementation</p>\n<p>```</p>\n<p>def _has_rational_power(expr):\n    a, p, q = Wild(\'a\'), Wild(\'p\'), Wild(\'q\')\n    pattern_match = expr.match(a<em>p</em>*q)\n    if pattern_match is None or pattern_match[a] is S.Zero:\n        return (False, None)\n    elif isinstance(pattern_match[q], Rational):\n        if not pattern_match[q].q == S.One:\n            return (True, pattern_match[q].q)</p>\n<div class="codehilite"><pre>if not isinstance(pattern_match[a], Pow) or isinstance(pattern_match[a], Mul):\n    return (False, None)\nelse:\n    return _has_rational_power(pattern_match[a])\n</pre></div>\n\n\n<p>```</p>', 'sort_key': None, 'max_subpages': None, 'template': 'default.haml', 'sort_reverse': True, 'date': datetime.datetime(2015, 4, 22, 0, 0), 'slug': u'week-10'}, {'category': '', 'index': False, 'subpages': [], 'target': u'gsoc-2014-with-sympy.html', 'title': '', 'url': u'gsoc-2014-with-sympy.html', 'checksum': '?\xc0\x04?\xd3\x13\x1d\xfe\xae\xfa\xdc\xf8=\xd4JZ', 'rel_site_url': '.', 'excerpt': u"Hi, I'm Harsh Gupta an undergrad student at IIT Kharagpur, I've been accepted this year for the Google Summer of Code program with Sympy. So, What is a Google Summer of Code? Google Summer of Code is a program by Google to promote opensource development. In this program Google pays ...", 'modified': 1429646554.476337, 'filename': '/home/hargup/210fs/posts/gsoc-2014-with-sympy.md', 'content': u'<!--\n.. title: GSoC 2014 with Sympy\n.. slug: gsoc-2014-with-sympy\n.. date: 2014/05/26 00:54:22\n.. tags:\n.. link:\n.. description:\n.. type: text\n-->\n\n<p>Hi, I\'m Harsh Gupta an undergrad student at IIT Kharagpur, I\'ve been accepted\nthis year for the Google Summer of Code program with Sympy.</p>\n<p><strong>So, What is a Google Summer of Code?</strong></p>\n<p>Google Summer of Code is a program by Google to promote opensource development.\nIn this program Google pays handsome stipends to students to work for various opensource\norganisations. In the application phase the students have to write proposals to\nthe organisations describing the projects they want to do\nand how do they fit for it. If the proposal is accepted the student is provided\nwith a mentor and with the guidance of the mentor the student has to complete\nthe project in the given timeline. You can look at my\n<a href="https://github.com/sympy/sympy/wiki/GSoC-2014-Application-Harsh-Gupta:-Solvers">proposal</a>.\nI proposed to work on improving the current equation solvers in\nSympy. My mentors for the Project are <a href="https://github.com/mrocklin">Matthew Rocklin</a>\nand <a href="https://github.com/skirpichev">Sergey B Kipirchev</a>.</p>\n<p><strong>A word about Sympy.</strong></p>\n<p><a href="http://sympy.org/">Sympy</a> is a pure python library for symbolic computation. Symbolic\ncomputation is similar to the maths you do by hands and it differs from\nnumerical computations. More about Symbolic and Numerical computation in\nsome other post. Sympy has been created by hundreds of contributors starting from 2006.\nIt has an awesome developer\ncommunity and we encourage outsiders to contribute and get their hands dirty with\nthe code. What do you need to start contributing? Some python skills and little\npatience. Download the <a href="https://github.com/sympy/sympy">latest development code</a>.\nGo through the <a href="https://github.com/sympy/sympy/wiki/Development-workflow">development workflow</a>.\nFind something to work on from the\n<a href="https://github.com/sympy/sympy/issues?labels=Easy+to+Fix&amp;milestone=&amp;page=1&amp;state=open">EasyToFix Issues</a>.\nCode it and send us a <a href="https://help.github.com/articles/using-pull-requests">pull request</a>. Happy Coding.</p>\n<p>I\'ll give a brief about the project aim and current state of work in the next post.\nI\'m looking forward for a great summer with Sympy.</p>', 'sort_key': None, 'max_subpages': None, 'template': 'default.haml', 'sort_reverse': True, 'date': datetime.datetime(2015, 4, 22, 0, 0), 'slug': u'gsoc-2014-with-sympy'}, {'category': '', 'index': False, 'subpages': [], 'target': u'what-is-symbolic-computation.html', 'title': '', 'url': u'what-is-symbolic-computation.html', 'checksum': 'p\x9e\x8f\xa3\xbc\xb8\x9ckg*c\x08\x9c\x1f\x17=', 'rel_site_url': '.', 'excerpt': u'Intro The fundamental limit Numerical Computation Symbolic Computation You have got function in maths, functions map some values to some other values. sin(x) is a function cos(x) is a function. Then we have got operators which map these functions to some other functions, say differentiation, integration then we have operations ...', 'modified': 1429646554.4803371, 'filename': '/home/hargup/210fs/posts/what-is-symbolic-computation.md', 'content': u'<!--\n.. title: what is symbolic computation\n.. slug: what-is-symbolic-computation\n.. date: 2014/05/21 01:10:52\n.. tags:\n.. link:\n.. description:\n.. type: text\n.. draft:\n-->\n\n<ul>\n<li>Intro</li>\n<li>The fundamental limit</li>\n<li>Numerical Computation</li>\n<li>Symbolic Computation</li>\n</ul>\n<!-- Seek an expert advice -->\n\n<!--\nI can have distance as a quantity which takes values from the real uncountable\nset. Can I build a computer which computes on a uncountable set, something in\nwhich I can code the direchlet\'s function??\n-->\n\n<p>You have got function in maths, functions map some values to some other values.\nsin(x) is a function cos(x) is a function. Then we have got operators which map\nthese functions to some other functions, say differentiation, integration then\nwe have operations like multiplication of matricies.</p>\n<!--\nGet a better beginning.\nExplain what do you mean by a computation.\n-->\n\n<p>People have to do computations by hand but what if you want to harness the\npower of modern computers. But if you want to do computations on functions\nwhich have real numbers as as their inputs you first need a method to represent\nthem on computers. But it turns out it impossible represent all the real numbes\nor a finite subset <!-- What do you mean by finite subset?? --> of real numbers\non a computer. In fact it can proved that it is impossible to reprsent real\nnumbers on a modern computer working on 0s and 1\'s or any computer by the way,\nthe one bases on turing machines, I don\'t know about the quantum computers.</p>\n<p>I can represent integers on a computer. How do I do it? The binary\nrepresentation of integers. If I have infinitely large memory I can represent\nany integer. How do I represent a rational number I can have a pair of\nintegers. I can say the odd bit corresponds to the first integer and the even\nbit corresponds to the second.</p>\n<p>So, what are representations. They are maps one-to-one maps. I give you some\nintegers and you should be able to tell what is the corresponding bit string.\nI should be able to tell the corresponding integer value if given a bit string.\nSimilarly the representations should have corresponding operators. I know how\nto add two integers then I should know how to add two representation of\nthose integers. In this case the corresponding operator turns out to be fairly\nsimple, the binary addition. Now if I need to represent real numbers on\na computer I need one to one mapping from the set of real numbers to binary\nstrings, that\'s equivalent to have a mapping from real number to the set of\nnatural numbers. That\'s impossible, yeah impossible and it was shown\nbeautifully by George Cantor in what is called the Cantor\'s diagonal argument.\n<!-- Read about Cantor -->\nI won\'t explain it here you read it from the links given in the end.\nSo, how the hell will I do compuations on real numbers when I cannot even\nrepresent them. And we need real valued functions every where, from rocket\nscience to the social science every where. <!-- Better examples --></p>\n<!-- TODO: explain the non computability of the operators too -->\n\n<p>Here\'s what we do, we replace the real numbers in question by their floating\npoint representations <!-- Numerical Analysis doesn\'t need the number to\nrepresentable, the argument is flawed. --> and we replace the usual operators\nby the approximate can compute.</p>\n<p>Differentials by finite difference operators.\n    d(f(x)     lim f(x + h) - f(x)\n    ------ =   h-&gt;0 --------------\n     dx                   h</p>\n<div class="codehilite"><pre> In general we don&#39;t know how to do the limit so we replace the h by a very\n small value. Here the error is of order h. For better result you do\n\nd(f(x)     lim f(x + h) - f(x - h)\n------ =   h-&gt;0 --------------\n dx                   2*h\n</pre></div>\n\n\n<p>This is numerical computation. You replace all the values and operators by the\nones for which you how to deal with. Derivatives by finite differences,\nintegrals by reimann\'s summation. The input is in terms of something you know\nhow to work with and output is in the same format.</p>\n<p>So, let\'s have an example. Say you have to compute the derivative of sin(x) at\npi/3. So the first thing you will do is to approximate pi with something you\ncan work with, that can be done by truncating the decimal or binary expansion\nof pi at some value. Let\'s do for 5 digits.</p>\n<p>Then you have to do differentiation you have to choose del x, let\'s that is 0.001\nThen you don\'t even <em>know</em> what sin(x) is, so what you do? You approximate\nsin(x) by truncating it\'s taylor series expansion at 0 to say 4 terms.\nNow you plug the values and get the result.</p>\n<p>It may seem that numerical compuations are useless, that they are too much\napproximation but it\'s cool because it work, it appears crude but it works.\nNumerical analysis is all about refining the techniques to be faster and more\nrobust, say by bounding and estimating the error. and don\'t ever need to have\na computer to do numerical analysis.</p>\n<!-- Show the calculations -->\n\n<p>Hey but why can\'t I simply output the exact answer, that is 1/2. I know already\nthe derivative of sin to be cos and we know the value of cos(pi/3) to be 1/2.\nWhy can\'t I use that knowledge to do the computation.</p>\n<p>Now you are entering the domain of symbolic computation. You take the exact\nrepresentation of rational number, not the floating point. Then you got\na function which you name as <code>sin</code>. and you have got some properties associated\nwith it.\nFor Pi you don\'t its exact value some placeholder symbol will do\nYou \'know\' the derivative of that function as some other function\n<code>cos</code> whoes some properties you know. These properties include the values of\nthe function at some point.</p>\n<p>When you want the program to compute the derivative of sin(pi/3) it uses it\'s\nknowdege to get cos(pi/3), then it knows cos(pi/3)</p>\n<p>By knowdege I mean simple conditional, if the argument is pi/3 then the value\nof cos(pi/3) is 1/2.</p>\n<p>Say in the computation you somehow got sin(1/10) you don\'t know what exact\nvalue it corresponds to. You can\'t simply output a rational number for it or\nsomehting like sqrt(2)/sqrt(71). So, what do you do? You leave it\nunevaluated. sin(1/10) is simply sin(1/10). Does it have any use this way? Yes,\nbecause it can change forms and you have got rules to combine sin(1/10) with\nother values, e.g., if you get somewhere get <code>sin(1/10)**2 + cos(1/10)**2</code> you\nsimplify it to 1 from the rules of trigonometry.</p>\n<p>Similarly for derivatives you <code>know</code> the derivative of elementary functions,\nyou \'know\' how to get the derivative of the combination of then from the chain\nrule and multiplication and quotient rule.</p>\n<p>So, you cna come with an algorithm for symbolic differentiation. That\'s the\nessense of symbolic computation. You have the functions and operators and their\nknow properties. And you use this knowledge in the techniques of computation.</p>\n<!-- Can possibly include Richard\'s problem here -->\n\n<!--\nWhat is a representation, Representation is an one to one mapping of the object\nto the bit strings in the computer.\n-->\n\n<!-- TODO: add links to Cantor\'s Diagonal Argument -->', 'sort_key': None, 'max_subpages': None, 'template': 'default.haml', 'sort_reverse': True, 'date': datetime.datetime(2015, 4, 22, 0, 0), 'slug': u'what-is-symbolic-computation'}, {'category': '', 'index': False, 'subpages': [], 'target': u'week-7.html', 'title': '', 'url': u'week-7.html', 'checksum': '^6\xa0\x97\xea\xa6CW)f\x0e\xec\x10\xb8%\x0b', 'rel_site_url': '.', 'excerpt': u'Week 7, 8 Fu Simplification In the early part of the week 7 was thinking and working on design decisions. I want the code to be very modular so that it could be easily extended by people other than me. This came up in a meeting with Matthew and I ...', 'modified': 1429646554.4803371, 'filename': '/home/hargup/210fs/posts/week-7.md', 'content': u'<h1>Week 7, 8</h1>\n<h2>Fu Simplification</h2>\n<p>In the early part of the week 7 was thinking and working on design decisions.\nI want the code to be very modular so that it could be easily extended by\npeople other than me. This came up in a meeting with Matthew and I want the\nsolvers to be like the Fu simplification explained by Matthew in this <a href="https://www.youtube.com/watch?v=QldxygVVj-s&amp;list=PLYx7XA2nY5GfuhCvStxgbynFNrxr3VFog&amp;index=20">Scipy\nTalk</a>.\nThe idea was that we can see solving an equation as series of transformations.\nIf we have a lot of small transformations such that the input type is same as\noutput type, and some notion of what makes a "better" output we can search though\nthe list of transformations running one on top of other. I also posted about\nit on the <a href="https://groups.google.com/forum/#!topic/sympy/42GdMJ9ssyM">mailing\nlist</a> which brought\nout some flaws in the preliminary design. The idea is pretty crude in the\ncurrent stage and I\'ll have to look deeper into it, but not now.</p>\n<p>I also discussed about the implementing a pattern dispached based solver\nsuggested by <a href="https://groups.google.com/d/msg/sympy/moSEFHop0n4/e2hBKRQ9WP4J">F.B</a>\non the mailing list. But we decided that it will be better if we finish the\nequation solver by the current technique first.</p>\n<h2>Intersection with S.Reals</h2>\n<p>I decribed in the last post that one way to solve trigonometric equation is\nrewriting them in terms of \\( exp \\). But that is \\( exp \\) in the complex domain and\nthe solution of \\(exp(x) = a \\) is \\( \\left\\{i \\left(2 \\pi\nn + \\arg{\\left (a \\right )}\\right) + \\log{\\left\n(\\left\\lvert{a}\\right\\rvert \\right )}\\; |\\; n \\in \\mathbb{Z}\\right\\}\n\\). Hence we have to filter out real solutions from the obtained solutions.\nThe filering is equivalent to the intersection of the solutions with the \\( \\mathbb{R}\n\\) set. Suppose \\( g(x) \\) and \\( h(x) \\) are real valued functions and we\nhave to perform\n$$ \\mathbb{R} \\cap \\left\\{g{\\left (n \\right )} + i h{\\left (n \\right )}\\; |\\; n \\in \\mathbb{Z}\\right\\} $$\nthen the answer will be simply\n$$ \\left\\{g{\\left (n \\right )}\\; |\\; n \\in \\left\\{h{\\left (n \\right )} = 0\\; |\\; n \\in \\mathbb{Z}\\right\\}\\right\\} $$</p>\n<p>Separate the real and imaginary parts and equate the imaginary to zero\nbut the problem was with the assumptions on the symbols. For example while\nseparating real and imaginary parts of the equation.</p>\n<div class="codehilite"><pre>In[]: (n + I*n).as_imag_real()\nOut[]:(re(n) - im(n), re(n) + im(n))\n</pre></div>\n\n\n<p>That is because <code>n</code> is by default complex, even in the <code>Lambda(..).expr</code>.\nI wrote some code to decide the\nassumption on the variable of imageset from the baseset. See <a href="https://github.com/sympy/sympy/pull/7694">PR\n7694</a>.\nThere was another issue that needs to be resolved\n<code>S.Integers.intersect(S.Reals)</code> doesn\'t evaluate to <code>S.Reals</code>.</p>\n<h2>LambertW and Multivariate Solvers</h2>\n<p>The method to solve equation containing exp and log function is using the\nLambertW function. LambertW function is the inverse of \\( x \\exp(x) \\).  The\nfunction is multivariate function both for the real and complex\ndomains and Sympy has only one branch implemented. This also leads us to loss\nof solutions. Aaron gave an example\n<a href="https://github.com/sympy/sympy/pull/2723#issuecomment-33760912">here</a>. But I\'m\npretty unfamiliar with solving by LambertW and LambertW itself and it will take\nme some time to build an understanding of them.\nAs an ad hoc solution I\'m using the code in the <code>_tsolve</code> in the\n<code>solvers.solvers</code> module to do at least what the current solvers can do.</p>\n<p>When the importing of <code>_tsolve</code> method was done. I started working on the\nmultivariate solvers. Here\'s how the current multivariate solvers work:</p>\n<p><strong>Solving single multivariate equation</strong></p>\n<ol>\n<li>\n<p>count the number of free symbols in f - no of symbols for\nequation. If the equation has exactly one symbol which is not asked for then\nuse <code>solve_undetermined_coeffs</code>, the <code>solve_undetermined_coeffs</code> find the\nvalues of the coefficient in a univariate polynomial such that it always\nequates to zero.</p>\n</li>\n<li>\n<p>Then for each symbol <code>solve_linear</code> is tried which tries to find a solution\nof that symbol in terms of constants or other symbols, the docstring says</p>\n<div class="codehilite"><pre>No simplification is done to f other than and mul=True expansion,\nso the solution will correspond strictly to a unique solution.\n</pre></div>\n\n\n</li>\n</ol>\n<p>So we don\'t have to worry about loosing a solution. For every symbol it is\nchecked if doesn\'t depend on previously solved symbols, if it does that\nsolution is discarded.</p>\n<ol>\n<li>For the symbols for which the above method failed, the <code>_solve</code> function is\ncalled for the equation for that variable and as above if the solution contains\na variable already solved then that solution is discarded.</li>\n</ol>\n<p><strong>System of equations in multiple variables</strong></p>\n<ul>\n<li>\n<p>Try to convert the system of equations into a system of polynomial equation\n  in variables</p>\n</li>\n<li>\n<p>If all the equations are linear solve then using <code>solve_linear_system</code>, check\n  the result and return it. If asked for particular solution solve using\n  <code>minsolve_linear_system</code></p>\n</li>\n<li>\n<p>If the number of symbols is same as the size of the system solve the\n  polynomial system using <code>solve_poly_system</code>. In case the system is\n  over-determined All the free symbols intersection the variables asked for are\n  calculated. Then for every subset of such symbols of length equal to that of\n  the system, an attempt to solve the equations by <code>solve_poly_system</code> is made.\n  Here if any of the solution depends on previously solved system the solution\n  is discarded.</p>\n</li>\n<li>\n<p>In the case there are failed equations:</p>\n<ul>\n<li>For every know result:</li>\n<li>Substitute every thing into the failed equation and see if the equation turns to zero.\n  if it does accept the result otherwise put it in the bad_results group.</li>\n<li>Then try to solve try to solve the failed equation using <code>solve</code> for each symbol.</li>\n<li>If that solution depends on any other previously solved symbols\n  discard it.</li>\n<li>If it doesn\'t satisfy other equations, discard it.</li>\n<li>Check if the solution doesn\'t set any denominator to zero, if it does\n  discard that solution.</li>\n<li>If it satisfies the above conditions substitute this value in know\n  solutions and add it as a new result.</li>\n</ul>\n</li>\n</ul>', 'sort_key': None, 'max_subpages': None, 'template': 'default.haml', 'sort_reverse': True, 'date': datetime.datetime(2015, 4, 22, 0, 0), 'slug': u'week-7'}]